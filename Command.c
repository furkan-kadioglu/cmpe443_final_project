#include "Command.h"

uint32_t DEGREE_OF_TURN = 1;
uint32_t NUMBER_OF_TURN = 0;
uint32_t REMAINING_DEGREE_OF_TURN = 0;

uint32_t MODE = TEST;
uint32_t MOVEMENT_DIR = STOPPED;
uint32_t isStoppedForLight = 0;

void FORWARD(){
	
	// Turn off interrupt
	NVIC_DisableIRQ(PWM0_IRQn);
	
	// Set Motor
	MOTOR_DRIVER_IN1_PORT->SET |= MOTOR_DRIVER_IN1_MASK;
	MOTOR_DRIVER_IN2_PORT->CLR |= MOTOR_DRIVER_IN2_MASK;
	MOTOR_DRIVER_IN3_PORT->SET |= MOTOR_DRIVER_IN3_MASK;
	MOTOR_DRIVER_IN4_PORT->CLR |= MOTOR_DRIVER_IN4_MASK;
	
	// Set Signal 
	BACK_SIGNAL_PORT->CLR |= BACK_SIGNAL_MASK;
	FORWARD_SIGNAL_PORT->SET |= FORWARD_SIGNAL_MASK;
	Finish_Signal();
	
	MOVEMENT_DIR = MOVING_FORWARD;
}

void BACK (){
	
	// Turn off interrupt
	NVIC_DisableIRQ(PWM0_IRQn);
	
	// Set Motor
	MOTOR_DRIVER_IN1_PORT->CLR |= MOTOR_DRIVER_IN1_MASK;
	MOTOR_DRIVER_IN2_PORT->SET |= MOTOR_DRIVER_IN2_MASK;
	MOTOR_DRIVER_IN3_PORT->CLR |= MOTOR_DRIVER_IN3_MASK;
	MOTOR_DRIVER_IN4_PORT->SET |= MOTOR_DRIVER_IN4_MASK;
	
	// Set Signal 
	BACK_SIGNAL_PORT->SET |= BACK_SIGNAL_MASK;
	FORWARD_SIGNAL_PORT->CLR |= FORWARD_SIGNAL_MASK;
	Finish_Signal();
	
	MOVEMENT_DIR = MOVING_BACKWARD;
}

void STOP(){
	
	// Turn off interrupt
	NVIC_DisableIRQ(PWM0_IRQn);
	
	MOTOR_DRIVER_IN1_PORT->SET |= MOTOR_DRIVER_IN1_MASK;
	MOTOR_DRIVER_IN2_PORT->SET |= MOTOR_DRIVER_IN2_MASK;
	MOTOR_DRIVER_IN3_PORT->SET |= MOTOR_DRIVER_IN3_MASK;
	MOTOR_DRIVER_IN4_PORT->SET |= MOTOR_DRIVER_IN4_MASK;
	
	BACK_SIGNAL_PORT->CLR |= BACK_SIGNAL_MASK;
	FORWARD_SIGNAL_PORT->CLR |= FORWARD_SIGNAL_MASK;
	Finish_Signal();
}

void RIGHT(uint32_t DEGREE){
	
	// Reset
	NUMBER_OF_TURN = 0;
	
	// Set Interrupt for 90 degrees
	NVIC_EnableIRQ(PWM0_IRQn);
	NVIC_ClearPendingIRQ(PWM0_IRQn);
	PWM_MOTOR->MCR |= 1;
	DEGREE_OF_TURN = DEGREE;
	
	// Set Motor
	MOTOR_DRIVER_IN1_PORT->CLR |= MOTOR_DRIVER_IN1_MASK;
	MOTOR_DRIVER_IN2_PORT->SET |= MOTOR_DRIVER_IN2_MASK;
	MOTOR_DRIVER_IN3_PORT->SET |= MOTOR_DRIVER_IN3_MASK;
	MOTOR_DRIVER_IN4_PORT->CLR |= MOTOR_DRIVER_IN4_MASK;
	
	// Set Signal 
	BACK_SIGNAL_PORT->CLR |= BACK_SIGNAL_MASK;
	FORWARD_SIGNAL_PORT->CLR |= FORWARD_SIGNAL_MASK;
	Start_Signal(RIGHT_SIGNAL_PORT, RIGHT_SIGNAL_MASK);
	
	MOVEMENT_DIR = TURNING_RIGHT;
}

void LEFT(uint32_t DEGREE){
	
	//Reset
	NUMBER_OF_TURN = 0;
	
	// Set Interrupt for 90 degrees
	NVIC_EnableIRQ(PWM0_IRQn);
	NVIC_ClearPendingIRQ(PWM0_IRQn);
	PWM_MOTOR->MCR |= 1;
	DEGREE_OF_TURN = DEGREE;
	
	// Set Motor
	MOTOR_DRIVER_IN1_PORT->SET |= MOTOR_DRIVER_IN1_MASK;
	MOTOR_DRIVER_IN2_PORT->CLR |= MOTOR_DRIVER_IN2_MASK;
	MOTOR_DRIVER_IN3_PORT->CLR |= MOTOR_DRIVER_IN3_MASK;
	MOTOR_DRIVER_IN4_PORT->SET |= MOTOR_DRIVER_IN4_MASK;
	
	// Set Signal 
	BACK_SIGNAL_PORT->CLR |= BACK_SIGNAL_MASK;
	FORWARD_SIGNAL_PORT->CLR |= FORWARD_SIGNAL_MASK;
	Start_Signal(LEFT_SIGNAL_PORT, LEFT_SIGNAL_MASK);
	
	MOVEMENT_DIR = TURNING_LEFT;
}

void AUTONOMOUS (void){
	MODE = AUTO;
}
void TESTING (void){
	MODE = TEST;
}

void STATUS (void) {
	sprintf(serialBuffer, 
	"{\"distance\":%d,\"light_level_left\":%d,\"light_level_right\":%d,\"op_mode\":\"%s\"}\r\n", 
	ultrasonicSensorDistance, LDR1_Last_Light_Level, LDR2_Last_Light_Level, stringFromMode(MODE));
	Response();
}

void FINISH(void){
	STOP();
	Request("FINISH\r\n");
}

void PWM0_IRQHandler(){
	
	PWM_MOTOR->IR |= 1;
	NUMBER_OF_TURN += 4;
	
	if(NUMBER_OF_TURN >= NUMBER_OF_CYCLE_PER_DEGREE * DEGREE_OF_TURN){
		STOP();
		MOVEMENT_DIR = STOPPED;
	}
}

uint32_t CALC_REMAINING_DEGREE_OF_TURN(){
	REMAINING_DEGREE_OF_TURN = DEGREE_OF_TURN - NUMBER_OF_TURN/NUMBER_OF_CYCLE_PER_DEGREE;
	return REMAINING_DEGREE_OF_TURN;
}


