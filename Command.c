#include "Command.h"

#define NUMBER_OF_CYCLE_PER_DEGREE 6
uint32_t DEGREE_OF_TURN = 1;
uint32_t NUMBER_OF_TURN = 0;

uint32_t MODE = TEST;
uint32_t MOVEMENT_DIR = STOPPED;
uint32_t isStoppedForLight = 0;

void FORWARD(){
	
	// Turn off interrupt
	NVIC_DisableIRQ(PWM0_IRQn);
	
	// Set Motor
	MOTOR_DRIVER_IN1_PORT->SET |= MOTOR_DRIVER_IN1_MASK;
	MOTOR_DRIVER_IN2_PORT->CLR |= MOTOR_DRIVER_IN2_MASK;
	MOTOR_DRIVER_IN3_PORT->SET |= MOTOR_DRIVER_IN3_MASK;
	MOTOR_DRIVER_IN4_PORT->CLR |= MOTOR_DRIVER_IN4_MASK;
	
	// Set Signal 
	BACK_SIGNAL_PORT->CLR |= BACK_SIGNAL_MASK;
	FORWARD_SIGNAL_PORT->SET |= FORWARD_SIGNAL_MASK;
	Finish_Signal();
	
}

void BACK (){
	
	// Turn off interrupt
	NVIC_DisableIRQ(PWM0_IRQn);
	
	// Set Motor
	MOTOR_DRIVER_IN1_PORT->CLR |= MOTOR_DRIVER_IN1_MASK;
	MOTOR_DRIVER_IN2_PORT->SET |= MOTOR_DRIVER_IN2_MASK;
	MOTOR_DRIVER_IN3_PORT->CLR |= MOTOR_DRIVER_IN3_MASK;
	MOTOR_DRIVER_IN4_PORT->SET |= MOTOR_DRIVER_IN4_MASK;
	
	// Set Signal 
	BACK_SIGNAL_PORT->SET |= BACK_SIGNAL_MASK;
	FORWARD_SIGNAL_PORT->CLR |= FORWARD_SIGNAL_MASK;
	Finish_Signal();
}

void STOP(){
	
	// Turn off interrupt
	NVIC_DisableIRQ(PWM0_IRQn);
	
	MOTOR_DRIVER_IN1_PORT->SET |= MOTOR_DRIVER_IN1_MASK;
	MOTOR_DRIVER_IN2_PORT->SET |= MOTOR_DRIVER_IN2_MASK;
	MOTOR_DRIVER_IN3_PORT->SET |= MOTOR_DRIVER_IN3_MASK;
	MOTOR_DRIVER_IN4_PORT->SET |= MOTOR_DRIVER_IN4_MASK;
	
	BACK_SIGNAL_PORT->CLR |= BACK_SIGNAL_MASK;
	FORWARD_SIGNAL_PORT->CLR |= FORWARD_SIGNAL_MASK;
	Finish_Signal();
}

void RIGHT(uint32_t DEGREE){
	
	// Reset
	NUMBER_OF_TURN = 0;
	
	// Set Interrupt for 90 degrees
	NVIC_EnableIRQ(PWM0_IRQn);
	NVIC_ClearPendingIRQ(PWM0_IRQn);
	PWM_MOTOR->MCR |= 1;
	DEGREE_OF_TURN = DEGREE;
	
	// Set Motor
	MOTOR_DRIVER_IN1_PORT->CLR |= MOTOR_DRIVER_IN1_MASK;
	MOTOR_DRIVER_IN2_PORT->SET |= MOTOR_DRIVER_IN2_MASK;
	MOTOR_DRIVER_IN3_PORT->SET |= MOTOR_DRIVER_IN3_MASK;
	MOTOR_DRIVER_IN4_PORT->CLR |= MOTOR_DRIVER_IN4_MASK;
	
	// Set Signal 
	BACK_SIGNAL_PORT->CLR |= BACK_SIGNAL_MASK;
	FORWARD_SIGNAL_PORT->CLR |= FORWARD_SIGNAL_MASK;
	Start_Signal(RIGHT_SIGNAL_PORT, RIGHT_SIGNAL_MASK);
	
}

void LEFT(uint32_t DEGREE){
	
	//Reset
	NUMBER_OF_TURN = 0;
	
	// Set Interrupt for 90 degrees
	NVIC_EnableIRQ(PWM0_IRQn);
	NVIC_ClearPendingIRQ(PWM0_IRQn);
	PWM_MOTOR->MCR |= 1;
	DEGREE_OF_TURN = DEGREE;
	
	// Set Motor
	MOTOR_DRIVER_IN1_PORT->SET |= MOTOR_DRIVER_IN1_MASK;
	MOTOR_DRIVER_IN2_PORT->CLR |= MOTOR_DRIVER_IN2_MASK;
	MOTOR_DRIVER_IN3_PORT->CLR |= MOTOR_DRIVER_IN3_MASK;
	MOTOR_DRIVER_IN4_PORT->SET |= MOTOR_DRIVER_IN4_MASK;
	
	// Set Signal 
	BACK_SIGNAL_PORT->CLR |= BACK_SIGNAL_MASK;
	FORWARD_SIGNAL_PORT->CLR |= FORWARD_SIGNAL_MASK;
	Start_Signal(LEFT_SIGNAL_PORT, LEFT_SIGNAL_MASK);
	
}

void AUTONOMOUS (void){
	MODE = AUTO;
}
void TESTING (void){
	MODE = TEST;
}

void STATUS (void) {
	sprintf(serialBuffer, "{\"distance\":%d,\"light_level_left\":%d,\"light_level_right\":%d,\"op_mode\":\"%s\"}\r\n", ultrasonicSensorDistance, LDR1_Last, LDR2_Last, stringFromMode(MODE));
	Response();
}

void FINISH(void){
	STOP();
	Request("FINISH\r\n");
}

void PWM0_IRQHandler(){
	
	PWM_MOTOR->IR |= 1;
	NUMBER_OF_TURN += 4;
	
	if(NUMBER_OF_TURN >= NUMBER_OF_CYCLE_PER_DEGREE * DEGREE_OF_TURN){
		// Turn off interrupt
		PWM_MOTOR->MCR &= ~1;
		NVIC_DisableIRQ(PWM0_IRQn);
		
		MOTOR_DRIVER_IN1_PORT->SET |= MOTOR_DRIVER_IN1_MASK;
		MOTOR_DRIVER_IN2_PORT->SET |= MOTOR_DRIVER_IN2_MASK;
		MOTOR_DRIVER_IN3_PORT->SET |= MOTOR_DRIVER_IN3_MASK;
		MOTOR_DRIVER_IN4_PORT->SET |= MOTOR_DRIVER_IN4_MASK;
		
		Finish_Signal();
		NUMBER_OF_TURN = 0;
	}
}


